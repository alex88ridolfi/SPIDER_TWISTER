#!/usr/bin/env python

#################### ALESSANDRO RIDOLFI ########################
#                      Version 1.5.1                           #
#           Bonn, December 2016 - Bonn, February 2020          #
################################################################

import numpy as np
import subprocess
import os, os.path, sys, glob, time, shutil, datetime
import multiprocessing
import matplotlib
if os.environ.get('DISPLAY','') == '':
        matplotlib.use('Agg')
import matplotlib.pyplot as plt

np.set_printoptions(threshold=np.inf)
string_version = "1.5.1 (03Feb2020)"

dict_param_formatters = {'PSR': "{:<17s}",'RAJ': "{:<9s}", 'DECJ': "{:<9s}",'PMRA': "{:<19s}",'PMDEC': "{:<19s}",'PX': "{:<20s}",'F0': "{:<6s}",'F1': "{:<8s}",'F2': "{:<8s}",'F3': "{:<8s}",'F4': "{:<8s}",'F5': "{:<8s}",'PEPOCH': "{:<14s}",'START': "{:<17s}",'FINISH': "{:<17s}",'DM': "{:<17s}",'DMEPOCH': "{:<15s}",'SOLARN0': "{:<21s}",'EPHEM': "{:<20s}",'CLK': "{:<20s}",'UNITS': "{:<20s}",'TIMEEPH': "{:<20s}",'T2CMETHOD': "{:<20s}",'CORRECT_TROPOSPHERE': "{:<20s}",'PLANET_SHAPIRO': "{:<20s}",'DILATEFREQ': "{:<20s}",'NTOA': "{:<23s}",'TRES': "{:<21s}",'TZRMJD': "{:<8s}",'TZRFRQ': "{:<18s}",'TZRSITE': "{:<25s}",'NITS': "{:<23s}",'BINARY': "{:<18s}",'A1': "{:<15s}",'E': "{:<14s}",'T0': "{:<10s}", 'TASC': "{:<10s}", 'OM': "{:<10s}",'PB': "{:<12s}",'FB0': "{:<7s}",'FB1': "{:<7s}",'FB2': "{:<7s}",'FB3': "{:<7s}",'FB4': "{:<7s}",'FB5': "{:<7s}",'FB6': "{:<7s}",'FB7': "{:<7s}",'FB8': "{:<7s}",'FB9': "{:<7s}",'FB10': "{:<7s}",'FB11': "{:<7s}",'FB12': "{:<7s}",'FB13': "{:<7s}",'GAMMA': "{:<17s}",'PBDOT': "{:<17s}",'OMDOT': "{:<17s}",'SINI': "{:<18s}",'MTOT': "{:<18s}",'M2': "{:<18s}",'EPS1': "{:<18s}",'EPS2': "{:<18s}"}

list_ordered_params_general = [ 'PSR',  'RAJ',  'DECJ', 'PMRA', 'PMDEC','PX','F0',   'F1',   'F2',   'F3',   'F4',   'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',  'PEPOCH',   'START', 'FINISH', 'DM', 'GLEP_1', 'GLPH_1', 'GLF0_1', 'GLF1_1', 'GLF0D_1', 'GLTD_1', 'GLEP_2', 'GLPH_2', 'GLF0_2', 'GLF1_2', 'GLF0D_2', 'GLTD_2', 'GLEP_3', 'GLPH_3', 'GLF0_3', 'GLF1_3', 'GLF0D_3', 'GLTD_3', 'DMEPOCH',   'SOLARN0','EPHEM','CLK','UNITS','TIMEEPH','T2CMETH OD','CORRECT_TROPOSPHERE','PLANET_SHAPIRO','DILATEFREQ','NTOA', 'TRES','TZRMJD','TZRFRQ','TZRSITE','NITS']

list_ordered_params_binary = ['BINARY', 'A1',   'E', 'OM',  'T0',   'EPS1', 'EPS2', 'TASC', 'OMDOT', 'PB', 'PBDOT', 'XPBDOT', 'FB0', 'FB1',   'FB2',   'FB3',   'FB4',   'FB5',   'FB6',   'FB7',   'FB8',   'FB9','FB10','FB11','FB12','FB13','GAMMA', 'SINI', 'MTOT', 'M2', 'XDOT', 'EDOT', 'DTHETA', 'DR']

def execute_and_log(command, work_dir, log_abspath, dict_envs={}, flag_append=0):
        datetime_start = (datetime.datetime.now()).strftime("%Y/%m/%d  %H:%M")
        time_start = time.time()
        if flag_append == 1:
                flag_open_mode = "a"
        else:
                flag_open_mode = "w+"
        log_file = open("%s" % (log_abspath), flag_open_mode)

        log_file.write("****************************************************************\n")
        log_file.write("START DATE AND TIME: %s\n" % (datetime_start))
        log_file.write("\nCOMMAND:\n")
        log_file.write("%s\n\n" % (command))
        log_file.write("WORKING DIRECTORY: %s\n" % (work_dir))
        log_file.write("****************************************************************\n")
        log_file.flush()

        list_for_Popen = command.split()
        env_subprocess = os.environ.copy()
        if dict_envs: #If the dictionary is not empty                                                                                                       
                for k in dict_envs.keys():
                        env_subprocess[k] = dict_envs[k]

        proc = subprocess.Popen(list_for_Popen, stdout=log_file, stderr=log_file, cwd=work_dir, env=env_subprocess)
        proc.communicate()  #Wait for the process to complete

        datetime_end = (datetime.datetime.now()).strftime("%Y/%m/%d  %H:%M")
        time_end = time.time()

        log_file.write("\nEND DATE AND TIME: %s\n" % (datetime_end))
        log_file.write("\nTOTAL TIME TAKEN: %d s\n" % (time_end - time_start))
        log_file.close()


def get_command_output(command):
        list_for_Popen = command.split()
        proc = subprocess.Popen(list_for_Popen, stdout=subprocess.PIPE)
        out, err = proc.communicate()
        return out

def get_command_output_with_pipe(command1, command2):
        list_for_Popen_cmd1 = command1.split()
        list_for_Popen_cmd2 = command2.split()
        p1 = subprocess.Popen(list_for_Popen_cmd1, stdout=subprocess.PIPE)
        p2 = subprocess.Popen(list_for_Popen_cmd2, stdin=p1.stdout, stdout=subprocess.PIPE)
        p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
        out, err = p2.communicate()
        return out


def import_parfile( infile ):
        parfile = open( infile, "r" )
        dict_parfile = {}
        for line in parfile:
                if line != "\n":
                        split_line = line.split()
                        dict_parfile[ split_line[0] ] = split_line[1]
                        if "D-" in dict_parfile[ split_line[0] ]:
                                dict_parfile[ split_line[0] ] = dict_parfile[ split_line[0] ].replace("D-", "e-")
                                
        return dict_parfile
                                                                                                                                        

def write_parfile_formatted( dict_parfile, list_parameters_to_fit, outname):
        f_parfile = open(outname, "w")
        
        for k in list_ordered_params_general + list_ordered_params_binary:
                if k in dict_parfile.keys():
                        string = dict_param_formatters[k].format(k) + str(dict_parfile[k])

                        if k in list_parameters_to_fit:
                                string = string + " 1\n"
                        else:
                                string = string + "\n"
                        string.replace("e-", "D-")
                        string.replace("e+", "D+")
                        f_parfile.write(string)
         
        f_parfile.close()

        
def calculate_number_of_steps(P, x_p_lts, ncpus, orbphase_interval):
        # Calculates the best number of steps, multiple of the number of cpus
        # via Eq. (5) of Ridolfi et al. (2016)
        
        N_steps_min = np.pi / np.arcsin(P / (8*x_p_lts)) * orbphase_interval
        N_steps = int(N_steps_min/np.float(ncpus) + 1)*ncpus
        return N_steps


def multiprocessing_function_caller(psrname, list_indices_to_process, array_list_T0s, array_T0_idnum, infile_basename, dict_parfile, queue_object, id_num, verbosity_level, workfolder_abspath):
        queue_object.put( [{'data': search_fraction_of_orbit(psrname, list_indices_to_process, array_list_T0s, array_T0_idnum, infile_basename, dict_parfile, id_num, verbosity_level, workfolder_abspath), 'id_num': id_num  }] )

        
def search_fraction_of_orbit(psrname, list_indices_to_process, array_trial_T0s, array_T0_idnum, infile_basename, dict_parfile, id_num, verbosity_level, workfolder_abspath):
        FNULL = open(os.devnull, 'w')
        workfolder_temp = "%s/temp_cpu_%02d" % (workfolder_abspath, id_num)
        os.chdir(workfolder_temp)
        #print
        #print "search_fraction_of_orbit:: array_trial_T0s = ", array_trial_T0s[list_indices_to_process[0]:list_indices_to_process[-1]]
        #print "search_fraction_of_orbit:: list_indices_to_process = " , list_indices_to_process
        for index in list_indices_to_process:
		T0         = array_trial_T0s[index]
                T0_idnum   = array_T0_idnum[index]
                
		label_file="%s_T%+06d" % (infile_basename, T0_idnum)

                current_parfile_name = "%s_T%+06d.par" % (psrname, T0_idnum)
		dict_parfile[key_T0]=T0

		write_parfile_formatted( dict_parfile, [], current_parfile_name)

                t0 = time.time()
                cmd = "prepfold -npart 512 -noxwin -n 64 -timing %s -o %05d_%s %s %s" % (current_parfile_name, index, label_file, infile, string_prepfold_options)
                log_abspath = workfolder_abspath + "/logs/log_%s.txt" % (label_file)
                if verbosity_level >= 2:
                        print
                        print "CPU #%d now trying T0 value of %.15f (array_trial_T0s[%d])" % (id_num, T0, index)
                        print "Working in directory: %s" % (os.getcwd())
                        print "cmd: ", cmd
                        print "Logging prepfold output into '%s'." % (log_abspath)
                        print
                
                


                if verbosity_level >= 2:
                        execute_and_log(cmd, os.getcwd(), log_abspath)
                else:
                        subprocess.call(cmd.split(), stdout=FNULL, stderr=FNULL)

                        
                for j in glob.glob("*.par") + glob.glob("*.pfd*"):
                        shutil.move(j, workfolder_abspath)
                        

def get_closest_T0_to_observation_Tstart(T_start, T0_parfile, Pb_d):
        N_orbits = int( (T_start - T0_parfile)/Pb_d  + 0.5)  #add half an orbit to get the closest T0 to the epoch of the observation
        T0_closest = T0_parfile + N_orbits*Pb_d

        return T0_closest

def round_up(nsteps, ncpus):
       return int(nsteps/np.float(ncpus) + 1)*ncpus    
        
def make_chisquare_vs_T0_plot():
        pass

###################################################
# DEFAULT PARAMETERS
###################################################
nosearch_string = ""
flag_this_epoch = 1
orbital_range = [-0.5,0.5]
ncpus = 1
nsteps = 0
verbosity_level = 1
flag_display = 0
flag_output_chi_vs_T0 = 1
nsteps_factor = 1
N_keep_best = 100
string_prepfold_options = ""
key_T0 = "T0"
list_best_folded_archives = []  #list of dictionaries {'id_num', 'pfd_file', 'parfile', 'chi_square'}
total_run_time = 0


###################################################
# SHELL ARGUMENTS
###################################################
if (len(sys.argv) == 1 or ("-h" in sys.argv) or ("-help" in sys.argv) or ("--help" in sys.argv)):
	print "USAGE: %s -par <parfile> -datfiles <files> [-nsteps N -orboffset \"-0.1,0.1\" -ncpus 4 -Q ]" % (os.path.basename(sys.argv[0]))
        print
        print "%18s    %-47s:  %-50s" % ("-h", "", "Print help")
        print "%18s    %-47s:  %-50s %s" % ("-par", "<parfile>", "TEMPO1 parfile", "")
        print "%18s    %-47s:  %-50s %s" % ("-datfiles", "<file1.dat>,...,<fileN.dat>", "PRESTO TOPOCENTRIC time series (.dat)", "")
        print "%18s    %-47s:  %-50s" % ("-fine", "", "Double the number of steps (for faint/narrow pulsar)")
        print "%18s    %-47s:  %-50s" % ("-nsteps", "[integer]  [default: Eq.(5) of Ridolfi+2016]", "Manually set the number of T0 trials")
        print "%18s    %-47s:  %-50s" % ("-orboffset", "\"-0.1,0.1\"  [default: \"-0.5,0.5\"]", "Orbital phase offset from nominal T0 to search")
        print "%18s    %-47s:  %-50s" % ("-ncpus", "[integer]  [default: 1]", "Number of cpus to use")
        print "%18s    %-47s:  %-50s" % ("-prepfold_options", "'-opt1 -opt2..'  [default: none]", "Options for PRESTO's prepfold")
        print "%18s    %-47s:  %-50s" % ("-keep_best", "{[integer],'all'}  [default: 100]", "Number of best detections to retain")
        print "%18s    %-47s:  %-50s" % ("-D", "", "Show live chisquare vs orbital offset plot")
        print "%18s    %-47s:  %-50s" % ("-Q", "", "Quiet mode - do not print anything")
        print "%18s    %-47s:  %-50s" % ("-V", "", "Very verbose mode - print many info to debug issues")
        print "%18s    %-47s:  %-50s" % ("-version", "", "Print the version of this code")
	exit()
else:
	for j in range( 1, len(sys.argv)):
                if (sys.argv[j] == "-par"):
                        parfile_abspath = os.path.abspath(sys.argv[j+1])
                elif (sys.argv[j] == "-datfiles"):
			string_files = sys.argv[j+1]
			if ("*" in string_files) or ("?" in string_files):
				list_files = [ os.path.abspath(x) for x in sorted(glob.glob(string_files.strip("\"")))]
			else:
				list_files = [ os.path.abspath(x) for x in string_files.replace(" ", "").split(",")]

                elif (sys.argv[j] == "-fine"):
                        nsteps_factor = 2
                                                                                
		elif (sys.argv[j] == "-nsteps"):
                        nsteps = int(sys.argv[j+1])

		elif (sys.argv[j] == "-orboffset"):
                        orbital_range = [np.float(x) for x in sys.argv[j+1].strip().split(",")]

                elif (sys.argv[j] == "-ncpus"):
                        ncpus = int(sys.argv[j+1])

                elif (sys.argv[j] == "-prepfold_options"):
                        string_prepfold_options = sys.argv[j+1]

                elif (sys.argv[j] == "-keep_best"):
                        N_keep_best_str = sys.argv[j+1]
                        if N_keep_best_str == "all":
                                N_keep_best = 0
                        else:
                                N_keep_best = int(N_keep_best_str)
                                
                elif (sys.argv[j] == "-D"):
                        flag_display = 1

                elif (sys.argv[j] == "-Q"):
                        verbosity_level = 0

                elif (sys.argv[j] == "-V"):
                        verbosity_level = 2

                elif (sys.argv[j] == "-version") or (sys.argv[j] == "--version") or (sys.argv[j] == "-v"):
                        print "Version: %s" % (string_version)
                        exit()


###################################################
# PARFILE READING
###################################################
dict_parfile = import_parfile(parfile_abspath)

try:
        binary_model = dict_parfile['BINARY']
except KeyError:
        print "ERROR: The ephemeris does not seem to include a binary model ('BINARY' keyword missing)!"
        exit()
        
try:
	Pb_d = np.float(dict_parfile['PB'])
	Pb_s = Pb_d*86400.
except KeyError:
	string_Fb0 = dict_parfile['FB0']
	Fb0 = np.float(string_Fb0)
	Pb_s = (1./Fb0)
	Pb_d = Pb_s/86400.

x_p_lts = np.float(dict_parfile['A1'])


try:
        ecc = np.float(dict_parfile['E'])
except KeyError:
        try:
                ecc = np.float(dict_parfile['ECC'])
        except KeyError:
                eps1 = np.float(dict_parfile['EPS1'])
                eps2 = np.float(dict_parfile['EPS2'])
                ecc = np.sqrt( eps1**2 + eps2**2)

try:
        omega_p_deg = np.float(dict_parfile['OM'])
except KeyError:
        omega_p_deg = np.arctan2(eps1, eps2) * 180./np.pi

                
try:               psrname = dict_parfile['PSRJ']
except KeyError:   psrname = dict_parfile['PSR']

try:	          T0_parfile = np.float(dict_parfile['T0'])
except KeyError:  T0_parfile = np.float(dict_parfile['TASC']); key_T0 = "TASC"

P = 1./np.float(dict_parfile['F0'])



###################################################
# CALCULATE RANGE OF T0s TO SEARCH
###################################################
orbital_interval = orbital_range[1] - orbital_range[0]
if nsteps == 0:
        nsteps = calculate_number_of_steps(P, x_p_lts, ncpus, orbital_interval) * nsteps_factor

# If the number of steps is not a multiple of the number of CPUs, round up to first multiple.
if nsteps % ncpus > 0:
        nsteps_old = nsteps
        nsteps = round_up(nsteps, ncpus)

        print
        print "WARNING: the chosen number of steps (%d) is not a multiple of the number of CPUs (%d)." % (nsteps_old, ncpus) 
        print "Rounding the number of steps up to %d..." % (nsteps)



        
dT0_s = (Pb_s * orbital_interval /nsteps)
dT0_MJD = dT0_s / 86400.
i = 0
old_chisquare = 0


N_files = len(list_files)
best_parfile = ""
best_pfd = ""

list_orbital_phase_borders = np.linspace(orbital_range[0],orbital_range[1], ncpus+1)

if (verbosity_level >= 1):
        print
        print "#"*62
        print "#" + " "*23 + "%s" % ("SPIDER_TWISTER") + " "*23 + "#"
        print "#" + " "*22 + "%s" % (string_version) + " "*21 + "#"
        print "#"*62
        print
        print "-"*62
        print "Binary System information:"
        print
        print "%40s: %12s" % ("Pulsar Name", psrname)
        print
        print "%40s: %12s" % ("Binary Model", binary_model)
        print "%40s: %12.6f" % ("Orbital Period (d)", Pb_d)
        print "%40s: %12.6f" % ("Projected Size of Pulsar Orbit (lt-s)", x_p_lts)
        print "%40s: %12.6f" % ("Epoch of Passage at Periastron (MJD)", T0_parfile)
        print "%40s: %12.6f" % ("Longitude of Periastron (deg)", omega_p_deg)
        print "%40s: %12.6f" % ("Eccentricity", ecc)
        print "-"*62
        print

        print "List of files to process:"
        for i in range(len(list_files)):
                print "%3d) %s " % (i+1, list_files[i])
        print
        print "Number of steps: %d" % (nsteps)
        print
        for n in range(ncpus):
                partial_orbital_range = [    list_orbital_phase_borders[n] ,   list_orbital_phase_borders[n+1] ]
                print "CPU %02d will search the orbital phase offsets: [%6.3f : %6.3f]" % (n, partial_orbital_range[0], partial_orbital_range[1])
        print


        

###################################################
# LOOP OVER FILES TO SEARCH
###################################################
for j in range(N_files):
        infile = list_files[j]
        infile_name = os.path.basename(infile).split("/")[-1]
	infile_basename = os.path.splitext(os.path.basename(infile).split("/")[-1])[0]
        if (verbosity_level >= 1):
                print "======================================================================================"
                print "Searching file \"%s\" (%2d/%2d)" % (infile_name, j+1,N_files )
                print "======================================================================================"
	launch_folder =  os.getcwd()
        
	workfolder = "T0_search_%s_%s" % (psrname, infile_basename)
        workfolder_abspath = os.path.abspath(workfolder)
        logfolder_abspath = os.path.join(workfolder_abspath, "logs")

        
	if not os.path.exists(workfolder_abspath):
                os.mkdir(workfolder_abspath)
        else:
                shutil.rmtree(workfolder_abspath)
                os.mkdir(workfolder_abspath)
                
        if verbosity_level >= 2:
                os.mkdir(logfolder_abspath)
                
	os.chdir(workfolder_abspath)
        
        inf_file = "/".join(infile.split("/")[:-1]) + "/" + infile_basename + ".inf"

                
        if (verbosity_level >= 1 ):
                print get_command_output_with_pipe("cat %s" % (inf_file), "grep Epoch")
        
        flag_is_barycentered = int(get_command_output_with_pipe("cat %s" % (inf_file), "grep Barycentered").strip().split("=")[-1])
        if flag_is_barycentered == 1:
                print "ERROR: The input time series seems to be barycentered. SPIDER_TWISTER only works with TOPOCENTRIC PRESTO time series!"
                print "To fix this, run \"prepdata\" on your original search-mode data using the \"-nobary\" option."
                exit()
                
        T_start = np.float(get_command_output_with_pipe("cat %s" % (inf_file), "grep Epoch").strip().split("=")[-1]  )
        
                
        T0_closest = get_closest_T0_to_observation_Tstart(T_start, T0_parfile, Pb_d)
        T0_start  = T0_closest + Pb_d*orbital_range[0]
        T0_end    = T0_closest + Pb_d*orbital_range[1]

        array_index              = range(nsteps)
        array_chisquares         = np.zeros(nsteps)
        
        array_trial_T0s =        np.linspace(T0_start, T0_end, nsteps)
        array_orbphase_offsets   = np.linspace(orbital_range[0], orbital_range[1], nsteps)

        T0_idnum_min = int(nsteps*(array_orbphase_offsets[0]/orbital_interval))
        T0_idnum_max = T0_idnum_min + nsteps
        array_T0_idnum           = range(T0_idnum_min, T0_idnum_max, 1)

        if flag_display == 1:
                plt.ion()
                fig = plt.figure()
                ax = fig.add_subplot(111)
                plt.xlabel("Orbital Phase Offset")
                plt.ylabel("Chi Square")

                line1, = ax.plot(array_orbphase_offsets, array_chisquares, 'b-')


        if verbosity_level >= 2:
                print "Pb (days)     = %21.15f" % (Pb_d)
                print "T0_parfile    = %.15f" % (T0_parfile)
                print
                print "T_start (obs) = %.15f" % (T_start)
                print
                print "T0_closest    = %.15f" % (T0_closest)
                print
                print "Orb_offsets   = %.3f | %.3f" % (orbital_range[0], orbital_range[1])
                print "T0_start      = %.15f" % (T0_start)
                print "T0_end        = %.15f" % (T0_end)
                print "dT0_MJD       = %.15f" % (dT0_MJD)
                print
                print "array_trial_T0s = %s" % (array_trial_T0s)
                print
                print "array_orbphase_offsets = %s" % (array_orbphase_offsets)
                print
                print "array_T0_idnum         = %s" % (array_T0_idnum)
                print
                print "array_index            = %s" % (array_index)
                print
                print "len(array_trial_T0s)        = %d" % len(array_trial_T0s)
                print "len(array_orbphase_offsets) = %d" % len(array_orbphase_offsets)
                print "len(array_T0_idnum)         = %d" % len(array_T0_idnum)
                print "len(array_index)            = %d" % len(array_index)
                print 

        program_t_start = time.time()

        my_queue = multiprocessing.Queue()
        my_processes = []
        list_result_program = []
        
        n_steps_todo = 0
        n_steps_per_cpu = int(nsteps/ncpus)

        for n in range(ncpus):
                
                list_indices_to_process = array_index[ n*n_steps_per_cpu: (n+1)*n_steps_per_cpu ]
                n_steps_todo = n_steps_todo + len(list_indices_to_process)
                if verbosity_level >= 2:
                        print "CPU %d will process indices: %s" % (n, list_indices_to_process)
                        print "n_steps_todo = %d" % (n_steps_todo)
                        print "*******************************"
                        print
                my_processes.append( multiprocessing.Process(target=multiprocessing_function_caller, args=(psrname, list_indices_to_process, array_trial_T0s, array_T0_idnum, infile_basename, dict_parfile, my_queue, n, verbosity_level, workfolder_abspath)))
                os.mkdir("%s/temp_cpu_%02d" % (workfolder_abspath, n))

        

        for j in range(len(my_processes)):
                p = my_processes[j]
                string_cpus = ""
                for k in range(0,j+1):
                        if k > 0:    string_cpus = string_cpus + ", "
                        string_cpus = string_cpus + "%2d" % k
                if (verbosity_level >= 1):
                        sys.stdout.write("\rLaunching processing on CPU %s..." % (string_cpus)); sys.stdout.flush()
                        
                p.start()
                time.sleep(0.25)
                

        
        n_files_processed = 0
        best_folded_archive = ""
        best_chi_square = 0
        list_bestprofs = []
        list_old_bestprofs = []
        
        time.sleep(2.0)

        while (n_files_processed < n_steps_todo):

                search_string = workfolder_abspath + "/*.bestprof"
                        
                list_current_bestprofs = glob.glob(search_string)
                list_NEW_bestprofs = [x for x in list_current_bestprofs if x not in list_old_bestprofs]
                list_old_bestprofs = list_old_bestprofs + list_NEW_bestprofs
                n_files_processed = len(list_old_bestprofs)
                

                for f in list_NEW_bestprofs:
                        
                        f_pfd_name = f.split("/")[-1].split(".bestprof")[0]
                        f_pfd_abspath = os.path.abspath(f_pfd_name)
                        if "T+" in f:
                                f_T0_idnum =  +int(f.split("T+")[-1].split("_")[0])
                        elif "T-" in f:
                                f_T0_idnum =  -int(f.split("T-")[-1].split("_")[0])
                        else:
                                print "ERROR: cannot get the T0 id number!"
                                exit()

                        f_parfile_name = "%s_T%+06d.par" % (psrname, f_T0_idnum)
                        f_parfile_name_abspath = os.path.abspath(f_parfile_name)

                        f_index_array = f_T0_idnum - array_T0_idnum[0]
                        
                        try:
                                chi = np.float(get_command_output_with_pipe("cat %s" % (f), "grep Reduced").split("=")[-1])
                        except ValueError:
                                chi = 0
                                print "WARNING: could not convert the chi-square of file \"%s\" into float. Set to 0 and continuing..." % (f)

                        list_best_folded_archives.append(  {'pfd_name': f_pfd_name, 'parfile': f_parfile_name, 'chi': chi, 'T0_idnum': f_T0_idnum, 'index_array': f_index_array })
                        array_chisquares[f_index_array] = chi

                        
                        
                        list_best_folded_archives = sorted(list_best_folded_archives, key=lambda k: k['chi'])

                                
                        #Keep just the best N_keep_best
                        if N_keep_best > 0:
                                list_dict_to_delete = list_best_folded_archives[:-N_keep_best]

                                del list_best_folded_archives[:-N_keep_best]
                                for f_to_delete in list_dict_to_delete:
                                        list_files_to_remove = glob.glob("%s/%s*" % (workfolder_abspath,f_to_delete['pfd_name'])) + ["%s/%s" % (workfolder_abspath,f_to_delete['parfile'])]
                                        for f_rm in list_files_to_remove:
                                                os.remove(f_rm)
                        
                        if chi > best_chi_square:
                                best_chi_square = chi

                                
                                
                                
                                best_folded_archive = f.split("/")[-1].replace(".bestprof", "")
                                best_folded_archive_ps = f.split("/")[-1].replace(".bestprof", ".ps")
                                best_folded_archive_png = f.split("/")[-1].replace(".bestprof", ".png")


                                if "T+" in f:
                                        T0_idnum = +int(f.split("T+")[-1].split("_")[0])
                                elif "T-" in f:
                                        T0_idnum = -int(f.split("T-")[-1].split("_")[0])
                                
                                best_parfile_name = "%s_T%+06d.par" % (psrname, T0_idnum)
                                best_parfile_name_abspath = os.path.abspath(best_parfile_name)
                                best_detection_pfd_abspath = os.path.abspath(best_folded_archive)
                                best_detection_pfd_ps_abspath = os.path.abspath(best_folded_archive_ps)
                                best_detection_pfd_png_abspath = os.path.abspath(best_folded_archive_png)
                                
                                parfile_symlink_abspath = "%s/%s_best_parfile.par" % (launch_folder, workfolder)
                                pfdfile_symlink_abspath = "%s/%s_best_detection.pfd" % (launch_folder, workfolder)
                                psfile_symlink_abspath = "%s/%s_best_detection.pfd.ps" % (launch_folder, workfolder)
                                pngfile_symlink_abspath = "%s/%s_best_detection.pfd.png" % (launch_folder, workfolder)

                                try:
                                        os.symlink(best_parfile_name_abspath, parfile_symlink_abspath)
                                except OSError:
                                        os.remove(parfile_symlink_abspath)
                                        os.symlink(best_parfile_name_abspath, parfile_symlink_abspath)

                                try:
                                        os.symlink(best_detection_pfd_abspath, pfdfile_symlink_abspath) 
                                except OSError:
                                        os.remove(pfdfile_symlink_abspath)
                                        os.symlink(best_detection_pfd_abspath, pfdfile_symlink_abspath)

                                try:
                                        os.symlink(best_detection_pfd_ps_abspath, psfile_symlink_abspath) 
                                except OSError:
                                        os.remove(psfile_symlink_abspath)
                                        os.symlink(best_detection_pfd_ps_abspath, psfile_symlink_abspath)

                                try:
                                        os.symlink(best_detection_pfd_png_abspath, pngfile_symlink_abspath) 
                                except OSError:
                                        os.remove(pngfile_symlink_abspath)
                                        os.symlink(best_detection_pfd_png_abspath, pngfile_symlink_abspath)

                                        
                #list_old_bestprofs = list_current_bestprofs
                
                time.sleep(4.0)
                time_elapsed = time.time() - program_t_start
                processing_speed_steps_per_min = 60*n_files_processed/time_elapsed
                try:
                        ETA_min = (n_steps_todo - n_files_processed)/processing_speed_steps_per_min
                except:
                        ETA_min = np.nan
                        
                if (verbosity_level >= 1):
                        sys.stdout.write('\rProgress: %d/%d (%.1f%% / ETA: %.2f min)  |  Speed: %6.2f steps/min  |  Best detection: "%s"  (chi2 = %5.3f)'  % (n_files_processed, n_steps_todo, 100.*n_files_processed/np.float(nsteps), ETA_min, processing_speed_steps_per_min, best_folded_archive, best_chi_square))
                        sys.stdout.flush()

                        if flag_display == 1:
                                line1.set_ydata(array_chisquares)
                                # recompute the ax.dataLim
                                ax.relim()
                                # update ax.viewLim using the new dataLim
                                ax.autoscale_view()
                                fig.canvas.draw()

                                
                        
        best_T0_index = best_folded_archive.split("_PSR_")[0].split("_T")[-1]
        best_parfile_name = "%s_T%s.par" % (psrname, best_T0_index)
        best_T0 = array_trial_T0s[np.argmax(array_chisquares)]
        best_delta_T0 = best_T0 - T0_closest
        best_orbphase_offset = best_delta_T0/Pb_d
        
        
        if flag_output_chi_vs_T0 == 1:
                Chi_vs_T0_filename = "%s_chi2_vs_T0.png" % workfolder_abspath
                Chi_vs_T0_filename_nopath = os.path.basename(Chi_vs_T0_filename)
                print
                print
                print "Saving Chi2 vs T0 plot onto file...",; sys.stdout.flush()
                #plt.figure(1)
                plt.figure(figsize=(7,6)) 
                plt.xlabel("Orbital Phase Offset")
                plt.ylabel("Chi Square")
                plt.title("PSR %s\n\nBest T0: %.12f\nBest orbital phase offset: %.12f (%.5f s)" % (psrname, best_T0, best_orbphase_offset, best_orbphase_offset*Pb_s))
                plt.axvline(x=0, color='k', linestyle='dashed')
                plt.axvline(x=best_orbphase_offset, color='r', linestyle='dotted')
                plt.xticks(rotation=20)
                plt.plot(array_orbphase_offsets, array_chisquares, "k-")
                
                plt.tight_layout()
                plt.savefig(Chi_vs_T0_filename)
                print "done!"; sys.stdout.flush()

        program_t_end = time.time()
        program_run_time_s = program_t_end - program_t_start
        
        if (verbosity_level >= 1):
                sys.stdout.write('\n'); sys.stdout.flush()
                print "======================================================================================"
                print "T0-search of file \"%s\" completed!" % (infile_name)
                print
                print "%26s: \033[1m%.12f\033[0m" % ("Best T0", best_T0)
                print "%26s: \033[1m%.12f (= %.6f s)\033[0m" % ("Orbital phase offset",best_orbphase_offset, best_orbphase_offset*Pb_s)
                print "%26s: \033[1m%s\033[0m" % ("Best detection", os.path.basename(pfdfile_symlink_abspath))
                print "%26s: \033[1m%s\033[0m" % ("Chi square", best_chi_square)
                print "%26s: \033[1m%s\033[0m" % ("Associated parfile", best_parfile_name)
                if flag_output_chi_vs_T0 == 1:
                        print "%26s: \033[1m%s\033[0m" % ("Chi2 vs T0 plot:", Chi_vs_T0_filename_nopath)
                print "======================================================================================"
                print
                print "Total time taken: %.2f minutes" % (program_run_time_s / 60.)
                print

                
                
        for x in glob.glob("temp_cpu_*"):
                shutil.rmtree(x)
        os.chdir("..")
exit()


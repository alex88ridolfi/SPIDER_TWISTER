#!/usr/bin/env python3
#################### ALESSANDRO RIDOLFI ########################


import numpy as np
import os, os.path, sys, glob, time, shutil, datetime, copy, subprocess, multiprocessing

import matplotlib
if os.environ.get('DISPLAY','') == '':
        matplotlib.use('Agg')
import matplotlib.pyplot as plt

np.set_printoptions(threshold=np.inf)
string_version = "1.7.2 (06Oct2025)"

dict_param_formatters = {'PSR': "{:<17s}", 'PSRJ': "{:<17s}", 'RAJ': "{:<9s}", 'DECJ': "{:<9s}",'PMRA': "{:<19s}",'PMDEC': "{:<19s}",'PX': "{:<20s}",'F0': "{:<6s}",'F1': "{:<8s}",'F2': "{:<8s}",'F3': "{:<8s}",'F4': "{:<8s}",'F5': "{:<8s}",'PEPOCH': "{:<14s}",'START': "{:<17s}",'FINISH': "{:<17s}",'DM': "{:<17s}",'DMEPOCH': "{:<15s}",'SOLARN0': "{:<21s}",'EPHEM': "{:<20s}",'CLK': "{:<20s}",'UNITS': "{:<20s}",'TIMEEPH': "{:<20s}",'T2CMETHOD': "{:<20s}",'CORRECT_TROPOSPHERE': "{:<20s}",'PLANET_SHAPIRO': "{:<20s}",'DILATEFREQ': "{:<20s}",'NTOA': "{:<23s}",'TRES': "{:<21s}",'TZRMJD': "{:<8s}",'TZRFRQ': "{:<18s}",'TZRSITE': "{:<25s}",'NITS': "{:<23s}",'BINARY': "{:<18s}",'A1': "{:<15s}",'E': "{:<14s}",'T0': "{:<10s}", 'TASC': "{:<10s}", 'OM': "{:<10s}",'PB': "{:<12s}",'FB0': "{:<7s}",'FB1': "{:<7s}",'FB2': "{:<7s}",'FB3': "{:<7s}",'FB4': "{:<7s}",'FB5': "{:<7s}",'FB6': "{:<7s}",'FB7': "{:<7s}",'FB8': "{:<7s}",'FB9': "{:<7s}",'FB10': "{:<7s}",'FB11': "{:<7s}",'FB12': "{:<7s}",'FB13': "{:<7s}",'GAMMA': "{:<17s}",'PBDOT': "{:<17s}",'OMDOT': "{:<17s}",'SINI': "{:<18s}",'MTOT': "{:<18s}",'M2': "{:<18s}",'EPS1': "{:<18s}",'EPS2': "{:<18s}"}

list_ordered_params_general = [ 'PSR', 'PSRJ', 'RAJ',  'DECJ', 'PMRA', 'PMDEC','PX','F0',   'F1',   'F2',   'F3',   'F4',   'F5', 'F6', 'F7', 'F8', 'F9', 'F10', 'F11', 'F12',  'PEPOCH',   'START', 'FINISH', 'DM', 'GLEP_1', 'GLPH_1', 'GLF0_1', 'GLF1_1', 'GLF0D_1', 'GLTD_1', 'GLEP_2', 'GLPH_2', 'GLF0_2', 'GLF1_2', 'GLF0D_2', 'GLTD_2', 'GLEP_3', 'GLPH_3', 'GLF0_3', 'GLF1_3', 'GLF0D_3', 'GLTD_3', 'DMEPOCH',   'SOLARN0','EPHEM','CLK','UNITS','TIMEEPH','T2CMETH OD','CORRECT_TROPOSPHERE','PLANET_SHAPIRO','DILATEFREQ','NTOA', 'TRES','TZRMJD','TZRFRQ','TZRSITE','NITS']

list_ordered_params_binary = ['BINARY', 'A1',   'E', 'OM',  'T0',   'EPS1', 'EPS2', 'TASC', 'OMDOT', 'PB', 'PBDOT', 'XPBDOT', 'FB0', 'FB1',   'FB2',   'FB3',   'FB4',   'FB5',   'FB6',   'FB7',   'FB8',   'FB9','FB10','FB11','FB12','FB13','GAMMA', 'SINI', 'MTOT', 'M2', 'XDOT', 'EDOT', 'DTHETA', 'DR']

def execute_and_log(command, work_dir, log_abspath, dict_envs={}, flag_append=0):
        datetime_start = (datetime.datetime.now()).strftime("%Y/%m/%d  %H:%M")
        time_start = time.time()
        if flag_append == 1:
                flag_open_mode = "a"
        else:
                flag_open_mode = "w+"
        log_file = open("%s" % (log_abspath), flag_open_mode)

        log_file.write("****************************************************************\n")
        log_file.write("START DATE AND TIME: %s\n" % (datetime_start))
        log_file.write("\nCOMMAND:\n")
        log_file.write("%s\n\n" % (command))
        log_file.write("WORKING DIRECTORY: %s\n" % (work_dir))
        log_file.write("****************************************************************\n")
        log_file.flush()

        list_for_Popen = command.split()
        env_subprocess = os.environ.copy()
        if dict_envs: #If the dictionary is not empty                                                                                                            
                for k in list(dict_envs.keys()):
                        env_subprocess[k] = dict_envs[k]

        proc = subprocess.Popen(list_for_Popen, stdout=log_file, stderr=log_file, cwd=work_dir, env=env_subprocess)
        proc.communicate()  #Wait for the process to complete                                                                                                    

        datetime_end = (datetime.datetime.now()).strftime("%Y/%m/%d  %H:%M")
        time_end = time.time()

        log_file.write("\nEND DATE AND TIME: %s\n" % (datetime_end))
        log_file.write("\nTOTAL TIME TAKEN: %d s\n" % (time_end - time_start))
        log_file.close()


def get_command_output(command):
        list_for_Popen = command.split()
        proc = subprocess.Popen(list_for_Popen, stdout=subprocess.PIPE)
        out, err = proc.communicate()
        return out.decode('ascii')

def get_command_output_with_pipe(command1, command2):
        list_for_Popen_cmd1 = command1.split()
        list_for_Popen_cmd2 = command2.split()
        p1 = subprocess.Popen(list_for_Popen_cmd1, stdout=subprocess.PIPE)
        p2 = subprocess.Popen(list_for_Popen_cmd2, stdin=p1.stdout, stdout=subprocess.PIPE)
        p1.stdout.close()  # Allow p1 to receive a SIGPIPE if p2 exits.
        out, err = p2.communicate()
        return out.decode('ascii')


def myprint(string_to_print, outputfile, flag_to_file=1):
        print(string_to_print)
        if flag_to_file==1:
                outputfile.write("%s\n" % string_to_print)
        

def import_parfile( infile ):
        parfile = open( infile, "r" )
        dict_parfile = {}
        for line in parfile:
                if line != "\n":
                        split_line = line.split()
                        dict_parfile[ split_line[0] ] = split_line[1]
                        if "D-" in dict_parfile[ split_line[0] ]:
                                dict_parfile[ split_line[0] ] = dict_parfile[ split_line[0] ].replace("D-", "e-")
                                
        return dict_parfile
                                                                                                                                        

def write_parfile_formatted( dict_parfile, list_parameters_to_fit, outname):
        f_parfile = open(outname, "w")
        
        for k in list_ordered_params_general + list_ordered_params_binary:
                if k in list(dict_parfile.keys()):
                        string = dict_param_formatters[k].format(k) + str(dict_parfile[k])

                        if k in list_parameters_to_fit:
                                string = string + " 1\n"
                        else:
                                string = string + "\n"
                        string.replace("e-", "D-")
                        string.replace("e+", "D+")
                        f_parfile.write(string)
         
        f_parfile.close()

        
def calculate_number_of_steps(P, x_p_lts, ncpus, orbphase_interval):
        # Calculates the best number of steps, multiple of the number of cpus
        # via Eq. (5) of Ridolfi et al. (2016)
        
        N_steps_min = np.pi / np.arcsin(P / (8*x_p_lts)) * orbphase_interval
        N_steps = int(N_steps_min/np.float64(ncpus) + 1)*ncpus
        return N_steps


def multiprocessing_function_caller(psrname, list_indices_to_process, array_list_T0s, array_T0_idnum, infile_basename, dict_parfile, queue_object, id_num, verbosity_level, workfolder_abspath):
        queue_object.put( [{'data': search_fraction_of_orbit(psrname, list_indices_to_process, array_list_T0s, array_T0_idnum, infile_basename, dict_parfile, id_num, verbosity_level, workfolder_abspath), 'id_num': id_num  }] )

        
def search_fraction_of_orbit(psrname, list_indices_to_process, array_trial_T0s, array_T0_idnum, infile_basename, dict_parfile, id_num, verbosity_level, workfolder_abspath):
        FNULL = open(os.devnull, 'w')
        workfolder_temp = "%s/temp_cpu_%02d" % (workfolder_abspath, id_num)
        os.chdir(workfolder_temp)
        #print
        #print "search_fraction_of_orbit:: array_trial_T0s = ", array_trial_T0s[list_indices_to_process[0]:list_indices_to_process[-1]]
        #print "search_fraction_of_orbit:: list_indices_to_process = " , list_indices_to_process
        for index in list_indices_to_process:
                T0         = array_trial_T0s[index]
                T0_idnum   = array_T0_idnum[index]
                
                label_file="%s_T%+06d" % (infile_basename, T0_idnum)

                current_parfile_name = "%s_T%+06d.par" % (psrname, T0_idnum)
                dict_parfile[key_T0]=T0

                write_parfile_formatted( dict_parfile, [], current_parfile_name)

                t0 = time.time()
                cmd = "prepfold -npart 512 -noxwin -n 64 -timing %s -o %05d_%s %s %s" % (current_parfile_name, index, label_file, infile, string_prepfold_options)
                log_abspath = workfolder_abspath + "/logs/log_%s.txt" % (label_file)
                if verbosity_level >= 2:
                        print()
                        print("CPU #%d now trying T0 value of %.15f (array_trial_T0s[%d])" % (id_num, T0, index))
                        print("Working in directory: %s" % (os.getcwd()))
                        print("cmd: ", cmd)
                        print("Logging prepfold output into '%s'." % (log_abspath))
                        print()
                
                


                if verbosity_level >= 2:
                        execute_and_log(cmd, os.getcwd(), log_abspath)
                else:
                        subprocess.call(cmd.split(), stdout=FNULL, stderr=FNULL)

                        
                for j in glob.glob("*.par") + glob.glob("*.pfd*"):
                        shutil.move(j, workfolder_abspath)
                        

def get_closest_T0_to_observation_Tstart(T_start, T0_parfile, Pb_d):
        N_orbits = int( (T_start - T0_parfile)/Pb_d  + 0.5)  #add half an orbit to get the closest T0 to the epoch of the observation
        T0_closest = T0_parfile + N_orbits*Pb_d

        return T0_closest

def round_up(nsteps, ncpus):
       return int(nsteps/np.float64(ncpus) + 1)*ncpus    
        
def make_chisquare_vs_T0_plot():
        pass

###################################################
# DEFAULT PARAMETERS
###################################################
nosearch_string = ""
flag_this_epoch = 1
orbital_range = [-0.5,0.5]
ncpus = 1
nsteps = 0
verbosity_level = 1
flag_display = 0
flag_output_chi_vs_T0 = 1
nsteps_factor = 1
N_keep_best = 1
string_prepfold_options = ""
key_T0 = "T0"
list_best_folded_archives = []  #list of dictionaries {'id_num', 'pfd_file', 'parfile', 'chi_square'}
total_run_time = 0
flag_output_report = 1
flag_warn_about_nsteps_rounding = 0

###################################################
# SHELL ARGUMENTS
###################################################
if (len(sys.argv) == 1 or ("-h" in sys.argv) or ("-help" in sys.argv) or ("--help" in sys.argv)):
        print("USAGE: %s -par <parfile> -dat <PRESTO_timeseries> [-nsteps N -orboffset \"-0.1,0.1\" -ncpus 4 -Q ]" % (os.path.basename(sys.argv[0])))
        print()
        print("%18s    %-47s:  %-50s" % ("-h", "", "Print help"))
        print("%18s    %-47s:  %-50s %s" % ("-par", "<parfile>", "TEMPO1 parfile", ""))
        print("%18s    %-47s:  %-50s %s" % ("-dat", "<file.dat>", "PRESTO time series (.dat)", ""))
        print("%18s    %-47s:  %-50s" % ("-fine", "", "Double the number of steps (for faint/narrow pulsar)"))
        print("%18s    %-47s:  %-50s" % ("-nsteps", "[integer]  [default: Eq.(5) of Ridolfi+2016]", "Manually set the number of T0 trials"))
        print("%18s    %-47s:  %-50s" % ("-orboffset", "\"-0.1,0.1\"  [default: \"-0.5,0.5\"]", "Orbital phase offset from nominal T0 to search"))
        print("%18s    %-47s:  %-50s" % ("-ncpus", "[integer]  [default: 1]", "Number of cpus to use"))
        print("%18s    %-47s:  %-50s" % ("-prepfold_options", "'-opt1 -opt2..'  [default: none]", "Options for PRESTO's prepfold"))
        print("%18s    %-47s:  %-50s" % ("-keep_best", "{[integer],'all'}  [default: 1]", "Number of best detections to retain"))
        print("%18s    %-47s:  %-50s" % ("-noreport", "", "Don't write the report file"))
        print("%18s    %-47s:  %-50s" % ("-noplot", "", "Don't make the chi vs T0 plot"))
        #print("%18s    %-47s:  %-50s" % ("-D", "", "Show live chisquare vs orbital offset plot"))
        print("%18s    %-47s:  %-50s" % ("-Q", "", "Quiet mode - do not print anything"))
        print("%18s    %-47s:  %-50s" % ("-V", "", "Very verbose mode - print many info to debug issues"))
        print("%18s    %-47s:  %-50s" % ("-version", "", "Print the version of this code"))
        exit()
else:
        for j in range( 1, len(sys.argv)):
                if (sys.argv[j] == "-par"):
                        parfile_abspath = os.path.abspath(sys.argv[j+1])
                elif (sys.argv[j] == "-dat"):
                        infile          = os.path.abspath(sys.argv[j+1])
                        infile_name     = os.path.basename(infile).split("/")[-1]
                        infile_basename = os.path.splitext(os.path.basename(infile).split("/")[-1])[0]
			
                elif (sys.argv[j] == "-fine"):
                        nsteps_factor = 2
                                                                                
                elif (sys.argv[j] == "-nsteps"):
                        nsteps = int(sys.argv[j+1])

                elif (sys.argv[j] == "-orboffset"):
                        orbital_range = [np.float64(x) for x in sys.argv[j+1].strip().split(",")]

                elif (sys.argv[j] == "-ncpus"):
                        ncpus = int(sys.argv[j+1])

                elif (sys.argv[j] == "-prepfold_options"):
                        string_prepfold_options = sys.argv[j+1]

                elif (sys.argv[j] == "-keep_best"):
                        N_keep_best_str = sys.argv[j+1]
                        if N_keep_best_str == "all":
                                N_keep_best = 0
                        else:
                                N_keep_best = int(N_keep_best_str)

                elif (sys.argv[j] == "-noreport"):
                        flag_output_report = 0

                elif (sys.argv[j] == "-noplot"):
                        flag_output_chi_vs_T0 = 0
                        
                #elif (sys.argv[j] == "-D"):
                #        flag_display = 1

                elif (sys.argv[j] == "-Q"):
                        verbosity_level = 0

                elif (sys.argv[j] == "-V"):
                        verbosity_level = 2

                elif (sys.argv[j] == "-version") or (sys.argv[j] == "--version") or (sys.argv[j] == "-v"):
                        print("Version: %s" % (string_version))
                        exit()

launch_folder =  os.getcwd()
        
###################################################
# PARFILE READING
###################################################
dict_parfile_input = import_parfile(parfile_abspath)


dict_parfile = copy.deepcopy(dict_parfile_input)

try:
        binary_model = dict_parfile['BINARY']
except KeyError:
        print("ERROR: The ephemeris does not seem to include a binary model ('BINARY' keyword missing)!")
        exit()        
        
try:
	Pb_d = np.float64(dict_parfile['PB'])
	Pb_s = Pb_d*86400.
except KeyError:
	string_Fb0 = dict_parfile['FB0']
	Fb0 = np.float64(string_Fb0)
	Pb_s = (1./Fb0)
	Pb_d = Pb_s/86400.

x_p_lts = np.float64(dict_parfile['A1'])


try:
        ecc = np.float64(dict_parfile['E'])
except KeyError:
        try:
                ecc = np.float64(dict_parfile['ECC'])
        except KeyError:
                try:
                        eps1 = np.float64(dict_parfile['EPS1'])
                        eps2 = np.float64(dict_parfile['EPS2'])
                        ecc = np.sqrt( eps1**2 + eps2**2)
                except KeyError:
                        ecc = 0
                        print("WARNING: Eccentricity (E / ECC / EPS1+EPS2) parameter was not found in the ephemeris. Assuming it to be 0...")
                        
try:
        omega_p_deg = np.float64(dict_parfile['OM'])
except KeyError:
        if 'EPS1' in dict_parfile and 'EPS2' in dict_parfile:
                omega_p_deg = np.arctan2(eps1, eps2) * 180./np.pi
        else:
                omega_p_deg = 0
                print("WARNING: No OM nor EPS1+EPS2 parameters were found in the ephemeris. Assuming OM=0...")

                
try:               psrname = dict_parfile['PSRJ']
except KeyError:   psrname = dict_parfile['PSR']

try:	          T0_parfile = np.float64(dict_parfile['T0'])
except KeyError:  T0_parfile = np.float64(dict_parfile['TASC'])


for x in range(0,30):
        dict_parfile.pop("FB%d" % x, None)
dict_parfile['BINARY'] = "BT"
dict_parfile.pop("TASC", None)
dict_parfile.pop("EPS1", None)
dict_parfile.pop("EPS2", None)
dict_parfile.pop("PBDOT", None)
dict_parfile.pop("PSR", None)
dict_parfile['PSRJ'] = psrname
dict_parfile['PB'] = Pb_d
dict_parfile['E']  = ecc
dict_parfile['T0'] = T0_parfile
dict_parfile['OM'] = omega_p_deg


if psrname.startswith("J"):
        flag_psrname_starts_with_J = 1
        psrname_no_J = psrname[1:]
else:
        flag_psrname_starts_with_J = 0

        



P = 1./np.float64(dict_parfile['F0'])

workfolder                = "ST_%s_PSR_%s" % (infile_basename, psrname)
prepfold_best_basename    = "ST_%s_best" % (infile_basename)
workfolder_abspath        = os.path.abspath(workfolder)
logfolder_abspath         = os.path.join(workfolder_abspath, "logs")
report_filename_abspath   = "%s/%s_report.txt" % (launch_folder, workfolder)

if os.path.exists(report_filename_abspath):
        os.remove(report_filename_abspath)
        
if flag_output_report == 1:    report_file = open(report_filename_abspath, "w")
else:                          report_file = open(os.devnull, 'w')
        
ncpus_available = multiprocessing.cpu_count()

###################################################
# CALCULATE RANGE OF T0s TO SEARCH
###################################################
orbital_interval = orbital_range[1] - orbital_range[0]
if nsteps == 0:
        nsteps = calculate_number_of_steps(P, x_p_lts, ncpus, orbital_interval) * nsteps_factor

# If the number of steps is not a multiple of the number of CPUs, round up to first multiple.
if nsteps % ncpus > 0:
        nsteps_old = nsteps * nsteps_factor
        nsteps = round_up(nsteps_old, ncpus)
        flag_warn_about_nsteps_rounding = 1

dT0_s = (Pb_s * orbital_interval /nsteps)

dT0_MJD = dT0_s / 86400.
i = 0
old_chisquare = 0


best_parfile = ""
best_pfd = ""

list_orbital_phase_borders = np.linspace(orbital_range[0],orbital_range[1], ncpus+1)

if (verbosity_level >= 1):
        myprint("",                                                                      report_file, flag_output_report)
        myprint( "#"*62,                                                                 report_file, flag_output_report)
        myprint( "#" + " "*23 + "%s" % ("SPIDER_TWISTER") + " "*23 + "#",                report_file, flag_output_report)
        myprint( "#" + " "*23 + "%s" % (string_version) + " "*22 + "#",                  report_file, flag_output_report)
        myprint( "#"*62,                                                                 report_file, flag_output_report)
        if flag_output_report == 1:
                datetime_start = (datetime.datetime.now()).strftime("%Y/%m/%d  %H:%M")
                time_start = time.time()
                command = " ".join(sys.argv)
                report_file.write("\n")
                report_file.write("%s:\n" % ("COMMAND"))
                report_file.write("%s\n" % command)
                report_file.write("\n")
                report_file.write("%30s: %s\n" % ("START DATE AND TIME", datetime_start))
                report_file.write("%30s: %s\n" % ("WORKING DIRECTORY",launch_folder))
                report_file.write("%30s: %s\n" % ("TIME SERIES", infile))
                report_file.write("%30s: %s\n" % ("EPHEMERIS", parfile_abspath))                
                report_file.flush()


        myprint( "",                                                                     report_file, flag_output_report)
        myprint( "-"*62,                                                                 report_file, flag_output_report)
        myprint( "Binary System information:",                                           report_file, flag_output_report)
        myprint("",                                                                      report_file, flag_output_report)
        myprint( "%40s: %12s" % ("Pulsar Name", psrname),                                report_file, flag_output_report)
        myprint("",                                                                      report_file, flag_output_report)
        myprint( "%40s: %12s" % ("Binary Model", binary_model),                          report_file, flag_output_report)
        myprint( "%40s: %12.6f" % ("Orbital Period (d)", Pb_d),                          report_file, flag_output_report)
        myprint( "%40s: %12.6f" % ("Projected Size of Pulsar Orbit (lt-s)", x_p_lts),    report_file, flag_output_report)
        myprint( "%40s: %12.6f" % ("Epoch of Passage at Periastron (MJD)", T0_parfile),  report_file, flag_output_report)
        myprint( "%40s: %12.6f" % ("Longitude of Periastron (deg)", omega_p_deg),        report_file, flag_output_report)
        myprint( "%40s: %12.6f" % ("Eccentricity", ecc),                                 report_file, flag_output_report)
        myprint( "-"*62,                                                                 report_file, flag_output_report)
        myprint("",                                                                      report_file, flag_output_report)
        myprint("",                                                                      report_file, flag_output_report)
        if flag_warn_about_nsteps_rounding == 1:
                myprint("",                                                                      report_file, flag_output_report)
                myprint("WARNING: the chosen number of steps (%d) is not a multiple of the number of CPUs (%d). Rounding it up." % (nsteps_old, ncpus), report_file, flag_output_report) 
                myprint( "%20s: %d" % ("--> Number of steps", nsteps),                   report_file, flag_output_report)
        else:
                myprint( "%20s: %d" % ("Number of steps", nsteps),                       report_file, flag_output_report)
        myprint( "%20s: %.4f seconds" % ("Step size", dT0_s),                           report_file, flag_output_report)
        myprint("",                                                                      report_file, flag_output_report)
        for n in range(ncpus):
                partial_orbital_range = [    list_orbital_phase_borders[n] ,   list_orbital_phase_borders[n+1] ]
                myprint( "CPU %02d will search the orbital phase offsets: [%6.3f : %6.3f]" % (n, partial_orbital_range[0], partial_orbital_range[1]), report_file, flag_output_report)
        myprint("",                                                                      report_file, flag_output_report)


        ###################################################
        # CHECKS AND WARNINGS
        ###################################################                
        
        if ncpus == 1 and ncpus_available > 1:
                myprint("", report_file, flag_output_report)
                myprint("*** TIP ***: You are using only one thread but your system has %d CPUs! Consider running SPIDER_TWISTER with the '-ncpus %d' for a faster processing.\n" % (ncpus_available, ncpus_available), report_file, flag_output_report)

        if N_keep_best == 0:
                myprint("", report_file, flag_output_report)
                myprint("WARNING: You chose to keep all the folding trials! This can produce A LOT of small files, which might slow down your filesystem.\n", report_file, flag_output_report)

        if binary_model != 'BT':
                myprint("", report_file, flag_output_report)
                myprint("NOTICE: Your ephemeris has a '%s' binary model. The best ephemeris output by SPIDER_TWISTER will have a simple 'BT' model.\n" % (binary_model), report_file, flag_output_report)

        report_file.flush()

        
###################################################
# START SEARCH
###################################################

if (verbosity_level >= 1):
        print("======================================================================================")
        print("Searching file \"%s\"" % (infile_name))
        print("======================================================================================")


if not os.path.exists(workfolder_abspath):
        os.mkdir(workfolder_abspath)
else:
        shutil.rmtree(workfolder_abspath)
        os.mkdir(workfolder_abspath)

if verbosity_level >= 2:
        os.mkdir(logfolder_abspath)

os.chdir(workfolder_abspath)

inf_file = "/".join(infile.split("/")[:-1]) + "/" + infile_basename + ".inf"


if (verbosity_level >= 1 ):
        print(get_command_output_with_pipe("cat %s" % (inf_file), "grep Epoch"))

flag_is_barycentered = int(get_command_output_with_pipe("cat %s" % (inf_file), "grep Barycentered").strip().split("=")[-1])
if flag_is_barycentered == 1:
        print("WARNING: The input time series seems to be barycentered.")
        print("If you are using a recent version of PRESTO, this should be fine.")
        print("If you face issues, consider running \"prepdata\" on your search-mode data using the \"-nobary\" option.")
        print()

T_start = np.float64(get_command_output_with_pipe("cat %s" % (inf_file), "grep Epoch").strip().split("=")[-1]  )


T0_closest = get_closest_T0_to_observation_Tstart(T_start, T0_parfile, Pb_d)
T0_start  = T0_closest + Pb_d*orbital_range[0]
T0_end    = T0_closest + Pb_d*orbital_range[1]

array_index              = list(range(nsteps))
array_chisquares         = np.zeros(nsteps)

array_trial_T0s =        np.linspace(T0_start, T0_end, nsteps)
array_orbphase_offsets   = np.linspace(orbital_range[0], orbital_range[1], nsteps)

T0_idnum_min = int(nsteps*(array_orbphase_offsets[0]/orbital_interval))
T0_idnum_max = T0_idnum_min + nsteps
array_T0_idnum           = list(range(T0_idnum_min, T0_idnum_max, 1))

if flag_display == 1:
        plt.ion()
        fig = plt.figure()
        ax = fig.add_subplot(111)
        plt.xlabel("Orbital Phase Offset")
        plt.ylabel("Chi Square")

        line1, = ax.plot(array_orbphase_offsets, array_chisquares, 'b-')

if verbosity_level >= 2:
        print("Pb (days)     = %21.15f" % (Pb_d))
        print("T0_parfile    = %.15f" % (T0_parfile))
        print()
        print("T_start (obs) = %.15f" % (T_start))
        print()
        print("T0_closest    = %.15f" % (T0_closest))
        print()
        print("Orb_offsets   = %.3f | %.3f" % (orbital_range[0], orbital_range[1]))
        print("T0_start      = %.15f" % (T0_start))
        print("T0_end        = %.15f" % (T0_end))
        print("dT0_MJD       = %.15f" % (dT0_MJD))
        print()
        print("array_trial_T0s = %s" % (array_trial_T0s))
        print()
        print("array_orbphase_offsets = %s" % (array_orbphase_offsets))
        print()
        print("array_T0_idnum         = %s" % (array_T0_idnum))
        print()
        print("array_index            = %s" % (array_index))
        print()
        print("len(array_trial_T0s)        = %d" % len(array_trial_T0s))
        print("len(array_orbphase_offsets) = %d" % len(array_orbphase_offsets))
        print("len(array_T0_idnum)         = %d" % len(array_T0_idnum))
        print("len(array_index)            = %d" % len(array_index))
        print() 

program_t_start = time.time()

my_queue = multiprocessing.Queue()
my_processes = []
list_result_program = []

n_steps_todo = 0
n_steps_per_cpu = int(nsteps/ncpus)

for n in range(ncpus):

        list_indices_to_process = array_index[ n*n_steps_per_cpu: (n+1)*n_steps_per_cpu ]
        n_steps_todo = n_steps_todo + len(list_indices_to_process)
        if verbosity_level >= 2:
                print("CPU %d will process indices: %s" % (n, list_indices_to_process))
                print("n_steps_todo = %d" % (n_steps_todo))
                print("*******************************")
                print()
        my_processes.append( multiprocessing.Process(target=multiprocessing_function_caller, args=(psrname, list_indices_to_process, array_trial_T0s, array_T0_idnum, infile_basename, dict_parfile, my_queue, n, verbosity_level, workfolder_abspath)))
        os.mkdir("%s/temp_cpu_%02d" % (workfolder_abspath, n))



for j in range(len(my_processes)):
        p = my_processes[j]
        string_cpus = ""
        for k in range(0,j+1):
                if k > 0:    string_cpus = string_cpus + ", "
                string_cpus = string_cpus + "%2d" % k
        if (verbosity_level >= 1):
                sys.stdout.write("\rLaunching processing on CPU %s..." % (string_cpus)); sys.stdout.flush()

        p.start()
        time.sleep(0.25)



n_files_processed = 0
best_folded_archive = ""
best_chi_square = 0
best_T0_id_num = ""
list_bestprofs = []
list_old_bestprofs = []

time.sleep(2.0)

while (n_files_processed < n_steps_todo):

        search_string = workfolder_abspath + "/*.bestprof"

        list_current_bestprofs = glob.glob(search_string)
        list_NEW_bestprofs = [x for x in list_current_bestprofs if x not in list_old_bestprofs]
        list_old_bestprofs = list_old_bestprofs + list_NEW_bestprofs
        n_files_processed = len(list_old_bestprofs)


        for f in list_NEW_bestprofs:

                f_pfd_name = f.split("/")[-1].split(".bestprof")[0]
                f_pfd_abspath = os.path.abspath(f_pfd_name)
                if "T+" in f:
                        f_T0_idnum =  +int(f.split("T+")[-1].split("_")[0])
                elif "T-" in f:
                        f_T0_idnum =  -int(f.split("T-")[-1].split("_")[0])
                else:
                        myprint("ERROR: cannot get the T0 id number!", report_file, flag_output_report)
                        exit()

                f_parfile_name = "%s_T%+06d.par" % (psrname, f_T0_idnum)
                f_parfile_name_abspath = os.path.abspath(f_parfile_name)

                f_index_array = f_T0_idnum - array_T0_idnum[0]

                try:
                        chi = np.float64(get_command_output_with_pipe("cat %s" % (f), "grep Reduced").split("=")[-1])
                except ValueError:
                        chi = 0
                        myprint("WARNING: could not convert the chi-square of file \"%s\" into float. Set to 0 and continuing..." % (f), report_file, flag_output_report)

                list_best_folded_archives.append(  {'pfd_name': f_pfd_name, 'parfile': f_parfile_name, 'chi': chi, 'T0_idnum': f_T0_idnum, 'index_array': f_index_array })
                array_chisquares[f_index_array] = chi



                list_best_folded_archives = sorted(list_best_folded_archives, key=lambda k: k['chi'])


                #Keep just the best N_keep_best
                if N_keep_best > 0:
                        list_dict_to_delete = list_best_folded_archives[:-N_keep_best]

                        del list_best_folded_archives[:-N_keep_best]
                        for f_to_delete in list_dict_to_delete:
                                list_files_to_remove = glob.glob("%s/%s*" % (workfolder_abspath,f_to_delete['pfd_name'])) + ["%s/%s" % (workfolder_abspath,f_to_delete['parfile'])]
                                for f_rm in list_files_to_remove:
                                        os.remove(f_rm)

                if chi > best_chi_square:
                        if "T+" in f:
                                T0_idnum = +int(f.split("T+")[-1].split("_")[0])
                        elif "T-" in f:
                                T0_idnum = -int(f.split("T-")[-1].split("_")[0])
                        best_T0_idnum = T0_idnum
                        
                        best_chi_square = chi
                        best_folded_archive = f.split("/")[-1].replace(".bestprof", "")
                        best_folded_archive_ps = f.split("/")[-1].replace(".bestprof", ".ps")
                        best_folded_archive_png = f.split("/")[-1].replace(".bestprof", ".png")
                        best_folded_archive_polycos = f.split("/")[-1].replace(".bestprof", ".polycos")
                        best_folded_archive_bestprof = f.split("/")[-1].replace(".bestprof", ".bestprof")



                        best_parfile_name = "%s_T%+06d.par" % (psrname, best_T0_idnum)
                        best_parfile_name_abspath = os.path.abspath(best_parfile_name)
                        best_detection_pfd_abspath = os.path.abspath(best_folded_archive)
                        best_detection_pfd_ps_abspath = os.path.abspath(best_folded_archive_ps)
                        best_detection_pfd_png_abspath = os.path.abspath(best_folded_archive_png)
                        best_detection_pfd_polycos_abspath = os.path.abspath(best_folded_archive_polycos)
                        best_detection_pfd_bestprof_abspath = os.path.abspath(best_folded_archive_bestprof)

                        best_basename = "ST_%s_best_PSR_%s" % (infile_basename, psrname)
                        ST_best_par_abspath       = "%s/%s.par" % (launch_folder, best_basename)
                        ST_best_pfd_abspath       = "%s/%s.pfd" % (launch_folder, best_basename)
                        ST_best_bestprof_abspath  = "%s/%s.pfd.bestprof" % (launch_folder, best_basename)
                        ST_best_png_abspath       = "%s/%s.pfd.png" % (launch_folder, best_basename)
                        ST_best_polycos_abspath   = "%s/%s.pfd.polycos" % (launch_folder, best_basename)
                        ST_best_ps_abspath        = "%s/%s.pfd.ps" % (launch_folder, best_basename)

                        parfile_symlink_abspath = "%s/%s_temp_best.par" % (launch_folder, workfolder)
                        pfdfile_symlink_abspath = "%s/%s_temp_best.pfd" % (launch_folder, workfolder)
                        psfile_symlink_abspath  = "%s/%s_temp_best.pfd.ps" % (launch_folder, workfolder)
                        pngfile_symlink_abspath = "%s/%s_temp_best.pfd.png" % (launch_folder, workfolder)



                        try:
                                os.symlink(best_parfile_name_abspath, parfile_symlink_abspath)
                        except OSError:
                                os.remove(parfile_symlink_abspath)
                                os.symlink(best_parfile_name_abspath, parfile_symlink_abspath)

                        try:
                                os.symlink(best_detection_pfd_abspath, pfdfile_symlink_abspath) 
                        except OSError:
                                os.remove(pfdfile_symlink_abspath)
                                os.symlink(best_detection_pfd_abspath, pfdfile_symlink_abspath)

                        try:
                                os.symlink(best_detection_pfd_ps_abspath, psfile_symlink_abspath) 
                        except OSError:
                                os.remove(psfile_symlink_abspath)
                                os.symlink(best_detection_pfd_ps_abspath, psfile_symlink_abspath)

                        try:
                                os.symlink(best_detection_pfd_png_abspath, pngfile_symlink_abspath) 
                        except OSError:
                                os.remove(pngfile_symlink_abspath)
                                os.symlink(best_detection_pfd_png_abspath, pngfile_symlink_abspath)




        #list_old_bestprofs = list_current_bestprofs

        time.sleep(4.0)
        time_elapsed = time.time() - program_t_start
        processing_speed_steps_per_min = 60*n_files_processed/time_elapsed
        try:
                ETA_min = (n_steps_todo - n_files_processed)/processing_speed_steps_per_min
        except:
                ETA_min = np.nan

        if (verbosity_level >= 1):
                sys.stdout.write('\rProgress: %d/%d (%.1f%% / ETA: %.2f min)  |  Speed: %6.2f steps/min  |  Best detection: "%s"  (chi2 = %5.3f)'  % (n_files_processed, n_steps_todo, 100.*n_files_processed/np.float64(nsteps), ETA_min, processing_speed_steps_per_min, best_folded_archive, best_chi_square))
                sys.stdout.flush()

                if flag_display == 1:
                        line1.set_ydata(array_chisquares)
                        # recompute the ax.dataLim
                        ax.relim()
                        # update ax.viewLim using the new dataLim
                        ax.autoscale_view()
                        fig.canvas.draw()

                        
#Cleaning out the temporary files
for x in glob.glob("temp_cpu_*"):
        shutil.rmtree(x)

        
# Fold best parfile
os.chdir(launch_folder)
shutil.copy(best_parfile_name_abspath,            ST_best_par_abspath)


cmd_refold_best = "prepfold -npart 512 -noxwin -n 64 -timing %s -o %s %s %s" % (ST_best_par_abspath, prepfold_best_basename, infile, string_prepfold_options)
FNULL = open(os.devnull, 'w')
subprocess.call(cmd_refold_best.split(), stdout=FNULL, stderr=FNULL)

#Correct prepfold output file names to possibly include the J in the pulsar name
if flag_psrname_starts_with_J == 1:
        list_files_output_refold_best = glob.glob("%s*.pfd*" % prepfold_best_basename)
        for outfilename_prepfold in list_files_output_refold_best:
                old_outfilebasename_prepfold = outfilename_prepfold.split(".pfd")[0]
                extension = ".pfd%s" % outfilename_prepfold.split(".pfd")[-1]
                bad_basename  = "%s_PSR_%s" % (prepfold_best_basename, psrname_no_J)
                good_basename = "%s_PSR_%s" % (prepfold_best_basename, psrname)
                new_file_name = "%s%s" % (good_basename, extension)
                if old_outfilebasename_prepfold == bad_basename:
                        os.rename(outfilename_prepfold, new_file_name )


best_T0_index = best_folded_archive.split("_PSR_")[0].split("_T")[-1]
best_parfile_name = "%s_T%s.par" % (psrname, best_T0_index)
best_T0 = array_trial_T0s[np.argmax(array_chisquares)]
best_delta_T0 = best_T0 - T0_closest
best_orbphase_offset = best_delta_T0/Pb_d

###################################################################
#  Chi vs T0 Plot
###################################################################
Chi_vs_T0_filename = "%s_chi2_vs_T0.png" % (workfolder)
Chi_vs_T0_filename_abspath = os.path.abspath(Chi_vs_T0_filename)
if flag_output_chi_vs_T0 == 1:
        print()
        print()
        print("Saving Chi2 vs T0 plot onto file '%s'..." % (Chi_vs_T0_filename), end=' '); sys.stdout.flush()
        print("done!"); sys.stdout.flush()
        if flag_output_report == 1:
                report_file.write("\n\nChi2 vs T0 plot saved onto file '%s'.\n\n" % (Chi_vs_T0_filename))
                report_file.flush()
                
        #plt.figure(1)
        plt.figure(figsize=(7,6.5)) 
        plt.xlabel("Orbital Phase Offset")
        plt.ylabel("Chi Square")
        plt.title("PSR %s\nFile: %s\n\nBest T0: %.12f\nBest orbital phase offset: %.12f (%.5f s)" % (psrname, infile_name, best_T0, best_orbphase_offset, best_orbphase_offset*Pb_s))
        plt.axvline(x=0, color='k', linestyle='dashed')
        plt.axvline(x=best_orbphase_offset, color='r', linestyle='dotted')
        plt.xticks(rotation=20)
        plt.plot(array_orbphase_offsets, array_chisquares, "k-")

        plt.tight_layout()
        plt.savefig(Chi_vs_T0_filename)

else:
        if os.path.exists(Chi_vs_T0_filename_abspath):
                os.remove(Chi_vs_T0_filename_abspath)
###################################################################
        
program_t_end = time.time()
program_run_time_s = program_t_end - program_t_start

if (verbosity_level >= 1):
        sys.stdout.write('\n'); sys.stdout.flush()
        print()
        print("======================================================================================")
        print("T0-search of file \"%s\" completed!" % (infile_name))
        print()
        print("%26s: \033[1m%+06d\033[0m" % ("Best T0 trial number", best_T0_idnum))
        print("%26s: \033[1m%.12f\033[0m" % ("Best T0", best_T0))
        print("%26s: \033[1m%.12f (= %.6f s)\033[0m" % ("Orbital phase offset",best_orbphase_offset, best_orbphase_offset*Pb_s))
        print("%26s: \033[1m%s\033[0m" % ("Best detection", os.path.basename(ST_best_pfd_abspath)))
        print("%26s: \033[1m%s\033[0m" % ("Chi square", best_chi_square))
        print("%26s: \033[1m%s\033[0m" % ("Associated best parfile", os.path.basename(ST_best_par_abspath)))
        if flag_output_chi_vs_T0 == 1:
                print("%26s: \033[1m%s\033[0m" % ("Chi2 vs T0 plot", Chi_vs_T0_filename))
        print("======================================================================================")
        print()
        print("Total time taken: %.2f minutes" % (program_run_time_s / 60.))
        print()


if flag_output_report == 1:
        report_file.write("\n")
        report_file.write("======================================================================================\n")
        report_file.write("T0-search of file \"%s\" completed!\n" % (infile_name))
        report_file.write("\n")
        report_file.write("%26s: %+06d\n" % ("Best T0 trial number", best_T0_idnum))
        report_file.write("%26s: %.12f\n" % ("Best T0 value", best_T0))
        report_file.write("%26s: %.12f (= %.6f s)\n" % ("Orbital phase offset",best_orbphase_offset, best_orbphase_offset*Pb_s) )
        report_file.write("%26s: %s\n" % ("Best detection", ST_best_pfd_abspath))
        report_file.write("%26s: %s\n" % ("Chi square", best_chi_square))
        report_file.write("%26s: %s\n" % ("Associated best parfile", ST_best_par_abspath))
        if flag_output_chi_vs_T0 == 1:
                report_file.write("%26s: %s\n" % ("Chi2 vs T0 plot", Chi_vs_T0_filename))
        else:
                report_file.write("%26s: %s\n" % ("Chi2 vs T0 plot", "None (option '-noplot' was used)"))
        report_file.write("======================================================================================\n")
        report_file.write("\n")
        report_file.write("Total time taken: %.2f minutes\n" % (program_run_time_s / 60.))
        report_file.write("\n")
        report_file.close()





os.remove(parfile_symlink_abspath)
os.remove(pfdfile_symlink_abspath)
os.remove(psfile_symlink_abspath)
os.remove(pngfile_symlink_abspath)

if (N_keep_best == 1):
        shutil.rmtree(workfolder_abspath)

exit()

